= Лабораторная работа 6
:toc: macro
:toc-title: Оглавление
:figure-caption: Рисунок

include::Titulnik.adoc[]

toc::[]

== Введение

Цель работы — сделать лабораторную работу
Задание на следующую субботу:
1. Разобраться почему кнопка не работает
2. Заменить работу через системный таймер, на работу через TIM2 (сделать его настройку, запустить, проверять флаг переполнения)
3. Оформить лабу (с описанием системы тактирования, настройки на внеший, внутренний источник тактирования, PLL, добавить про порты, настройка, как работают зачем нужны, добавить про таймера - системный, TIM2) все описать своимо словами, с примерами кода, картинками и аккуратно оформить.

- переключение на внешний высокочастотный генератор(HSE) с помощью PLL;
- написать о системе тактирования микроконтроллера;
- настройка портов ввода/вывода;
- работа с системным таймером (SysTick) и таймерами общего назначения (TIM2);

== 1. Система тактирования STM32F411

=== 1.1 Доступные источники тактового сигнала

Микроконтроллер STM32F411 поддерживает несколько источников тактовой частоты:

* *HSI (High Speed Internal)* — внутренний RC-генератор 16 МГц
* *HSE (High Speed External)* — внешний кварцевый резонатор 8 МГц
* *PLL (Phase Locked Loop)* — система фазовой автоподстройки частоты
* *LSI/LSE* — низкочастотные генераторы для RTC и сторожевых таймеров

image::Тактирование.png[]
*Рисунок 1: Структура системы тактирования STM32F411*

=== 1.2 Переход на внешний генератор с использованием PLL
Поменял значение RCC_PLLCFGR_PLLM_Values в папке rccregisters.hpp, т.к. регистр PLLM в нем имел неверную информацию.

[cols="a,a"]
|===
| image::код.png[]
| image::PLL configuration.png[]
|===
*Рисунок 2: настройка регистра PLLM*

  Затем с помощью регистров PLLM, PLLN,PLLP подобрали частоту. В нашем случае необходимо получить f = 32Мгц, для этого подберем PLLM, PLLN,PLLP такие, чтобы выполнялась формула:
 f = f(PLL clock input) × (PLLN / PLLM) /PLLP​;
 32Мгц = 8*64/2/8; 

image::формула.png[]
*Рисунок 3: Фазовая подстройка частоты PLL*

 Четко, все регистры подобрал. Дальше выполню все необходимые шаги для переключения на HSE
  Шаг 1: Включение внешнего кварца (HSE)
  Шаг 2: Переключение на HSE как системную частоту
  Шаг 3: Настройка PLL (Phase-Locked Loop)
  Шаг 4: Запуск PLL и переключение на него
  Шаг 5: Включение системного контроллера
[source,cpp]
----
extern "C"
{
int __low_level_init(void)
{
  RCC::CR::HSEON::On::Set();
  while (RCC::CR::HSERDY::NotReady::IsSet())
  {
  }
  RCC::CFGR::SW::Hse::Set();
  while (!RCC::CFGR::SWS::Hse::IsSet())
  {

  }  
  RCC::CR::HSION::Off::Set();
  RCC::PLLCFGR::PLLSRC::HseSource::Set(); 
  RCC::PLLCFGR::PLLM::Set(2U);     // M = 2 
  RCC::PLLCFGR::PLLN::Set(64U);    // N = 64 
  RCC::PLLCFGR::PLLP::Set(3U);     // P = 8 
  RCC::CR::PLLON::On::Set();
  while (RCC::CR::PLLRDY::Unclocked::IsSet())
  {
  }
  RCC::CFGR::SW::Pll::Set();
  while (!RCC::CFGR::SWS::Pll::IsSet())
  {
  }
  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  return 1;
}
}
----

=== 1.3 Алгоритм настройки частоты

Алгоритм переключения на HSE включал следующие шаги:

. Включение внешнего кварца (HSE)
. Переключение на HSE как системную частоту
. Настройка параметров PLL
. Запуск PLL и переключение на него
. Включение системного контроллера

[source,cpp]
----
std::uint32_t SystemCoreClock = 16'000'000U;
extern "C" {
int __low_level_init(void)
{
  //Switch on external 16 MHz oscillator
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {
  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {
  }
  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  return 1;
}
}
----

Ниже приведено доказательство того что плата еще работает

image::плата.jpg[]

*Рисунок 4: плата*

== 2. Работа с портами ввода/вывода (GPIO)

=== 2.1 Режимы работы портов

Каждый вывод GPIO может работать в нескольких режимах:

* **Вход** — аналоговый или цифровой с подтяжкой к питанию/земле
* **Выход** — Push-Pull или Open-Drain
* **Альтернативная функция** — для работы с таймерами, UART, SPI и другой периферией

=== 2.2 Управляющие регистры (GPIO)

Основные регистры для настройки портов:

* `GPIOx_MODER` — выбор режима работы вывода
* `GPIOx_OTYPER` — тип выхода (Push-Pull/Open-Drain)
* `GPIOx_OSPEEDR` — скорость переключения
* `GPIOx_PUPDR` — настройка подтяжки
* `GPIOx_ODR` — данные на выходе
* `GPIOx_IDR` — данные на входе

Пример настройки вывода как выход Push-Pull:

[source,cpp]
----
// Включаем тактирование порта C
RCC::AHB1ENR::GPIOCEN::Enable::Set();

// Настраиваем вывод 5 как выход
GPIOC::MODER::MODER5::Output::Set();

// Тип выхода — Push-Pull (по умолчанию)
GPIOC::OTYPER::OT5::PushPull::Set();

// Скорость переключения — высокая
GPIOC::OSPEEDR::OSPEEDR5::VeryHigh::Set();

// Устанавливаем высокий уровень
GPIOC::ODR::ODR5::High::Set();
----

== 3. Таймеры микроконтроллера

=== 3.1 Системный таймер (SysTick)

SysTick — простой таймер, встроенный в ядро ARM Cortex-M4.

**Регистры SysTick**:

* `SYST_CSR` — управление таймером
* `SYST_LOAD` — значение перезагрузки
* `SYST_VAL` — текущее значение счётчика
Пример настройки задержки на 150 мс при частоте 32 МГц:

[source,cpp]
----
void tim2_delay(std::uint32_t milliseconds)
{
  TIM2::CR1::URS::OverflowEvent::Set();
  TIM2::PSC::Write(31999U);
  TIM2::ARR::Write(milliseconds - 1U);
  TIM2::SR::UIF::NoInterruptPending::Set();
  TIM2::CNT::Write(0);
  TIM2::CR1::CEN::Enable::Set();
  
  while (!TIM2::SR::UIF::InterruptPending::IsSet())
  {
  }
  TIM2::CR1::CEN::Disable::Set();
}
...
    tim2_delay(150);
----

=== 3.2 Таймер общего назначения TIM2

TIM2 — 32-битный таймер, поддерживающий различные режимы работы:
* Счёт вверх/вниз
* ШИМ-генерация
* Захват/сравнение

**Основные регистры TIM2**:

* `TIM2_CR1` — управление таймером
* `TIM2_PSC` — предделитель частоты
* `TIM2_ARR` — значение авто-перезагрузки
* `TIM2_CNT` — текущее значение счётчика
* `TIM2_SR` — регистр статуса

image::регистры.png[]
*Рисунок 3.1: Структура регистров TIM2*

== Вывод

Лабораторная работа выполнена успешно. Было выполнено переключение на внешний генератор HSE 8 МГц с последующим умножением частоты через PLL до 32 МГц. Реализована точная задержка 150 мс с использованием таймера TIM2. Работоспособность платы подтверждена.

=== Полный код программы

[source,cpp]

----
#include "iostream" //for std::cout
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOC
#include <array> // for std::array
#include "Led.h" // for Led, ILedToggable, ILedOnOff
#include "OptimizedLed.h" // for OptimizedLed
#include "CommonMode.h"
#include "RunningLightMode.h"
#include "FadeGlowMode.h"
#include "ChessMode.h"
#include "UserButton.h"
#include "ModeController.h"
#include "tim2registers.hpp" // ??? TIM2

std::uint32_t SystemCoreClock = 32'000'000U;

extern "C"
{
int __low_level_init(void)
{
  RCC::CR::HSEON::On::Set();
  while (RCC::CR::HSERDY::NotReady::IsSet())
  {
  }
  RCC::CFGR::SW::Hse::Set();
  while (!RCC::CFGR::SWS::Hse::IsSet())
  {
  }  
  RCC::CR::HSION::Off::Set();
  RCC::PLLCFGR::PLLSRC::HseSource::Set(); 
  RCC::PLLCFGR::PLLM::Set(2U);     // M = 2 
  RCC::PLLCFGR::PLLN::Set(64U);    // N = 64 
  RCC::PLLCFGR::PLLP::Set(3U);     // P = 8 
  RCC::CR::PLLON::On::Set();
  while (RCC::CR::PLLRDY::Unclocked::IsSet())
  {
  }
  RCC::CFGR::SW::Pll::Set();
  while (!RCC::CFGR::SWS::Pll::IsSet())
  {
  }
  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  
  // ????????? ???????????? ??? TIM2
  RCC::APB1ENR::TIM2EN::Enable::Set();
  return 1;
}
}
void tim2_delay(std::uint32_t milliseconds)
{
  TIM2::CR1::URS::OverflowEvent::Set();
  TIM2::PSC::Write(31999U); // ??? 1 ?? ??? 32 ???
  TIM2::ARR::Write(milliseconds - 1U);
  TIM2::SR::UIF::NoInterruptPending::Set();
  TIM2::CNT::Write(0);
  TIM2::CR1::CEN::Enable::Set();
  
  while (!TIM2::SR::UIF::InterruptPending::IsSet())
  {
  }
  TIM2::CR1::CEN::Disable::Set();
}
constexpr std::uint32_t buttonPinNum = 13;
constexpr std::uint32_t portCIdrAddress = 0x40020810U;
UserButton userButton(buttonPinNum, portCIdrAddress);

Led led1(5, 0x40020814U);
Led led2(8, 0x40020814U);
Led led3(9, 0x40020814U);
OptimizedLed<0x40020014U, 5> led4;

tLeds leds = 
{
  &led1,
  &led2,
  &led3,
  &led4
};
tLedsOnOff ledsOnOff = 
{
  &led1,
  &led2,
  &led3,
  &led4
};
RunningLightMode runningLightMode(leds, ledsOnOff);
FadeGlowMode fadeGlowMode(leds, ledsOnOff);
ChessMode chessMode(leds, ledsOnOff);

tModes modes
{
  &runningLightMode,
  &fadeGlowMode,
  &chessMode
};
ModeController modeController(modes);

int main()
{ 
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  GPIOA::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
  for(;;)
  {   
    if (userButton.WasPressed())
    {   
      modeController.SwitchMode(); 
    }
    modeController.RunCurrentMode(); 
    tim2_delay(150);
  }
  
  return 1;
}
----