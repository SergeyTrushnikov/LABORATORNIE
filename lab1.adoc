:toc: macro
:figure-caption: Рисунок

toc::[]

== Введение
=== Чем занимается отдел
Если просто: Они пишут все программы для умных датчиков (которые меряют давление и температуру) и для компьютеров, которые эти датчики настраивают и проверяют.

Что именно они делают:

Программы внутри самих датчиков (как прошивка в телефоне). Эти программы написаны на языке C++ и работают на маленьких микросхемах. Они следят, чтобы датчик правильно измерял и общался с другими приборами по специальным правилам (протоколам HART, CAN и др.).

Программы на компьютерах для заводских рабочих и инженеров. Эти программы:

Тестируют и настраивают датчики на заводе (написаны на C#).

Управляют всем производством (тоже на C# и с базой данных SQL).

Эмулируют оборудование — то есть создают виртуальные версии станков на компьютере, чтобы можно было проверять программы без дорогого железа.

== Как правильно делать программы
Главная мысль: Писать код без плана — это как строить дом без чертежа. Так делают только студенты или для очень маленьких задач. В серьёзной компании нужен порядок.

Как НЕ надо делать:

Сделал -> Проверил -> Переделал: Сначала быстренько написал код, потом стал его исправлять, пока не заработает. Это медленно, ненадёжно и приводит к хаосу в большом проекте.

Как делают у них:
Они используют умные системы планирования, главная из которых называется RUP (Рациональный унифицированный процесс). Её основные правила:

Думай о рисках заранее. Сначала реши самые сложные и опасные проблемы.

Сначала пойми, ЧТО нужно заказчику. Всё начинается с требований.

Будь готов к изменениям. Заказчик всегда будет что-то менять в процессе.

Сначала сделай каркас программы (архитектуру) и проверь его.

Постоянно проверяй качество на каждом шаге.

Работай дружной командой, где есть главные архитекторы.

Их внутренние правила (Rosemount Development Process):

Всё проверяют друг у друга. Любой документ или код должен посмотреть и одобрить другой инженер. Это называется Peer Review.

Есть специальный человек по качеству. Он следит, чтобы все работали по правилам.

Проходят два больших совещания по проекту: в начале (смотрят план) и в конце (смотрят, что получилось).

Есть главный по версиям (Менеджер конфигурации). Он следит, чтобы у всех были самые свежие файлы и ничего не потерялось.

==  Планирование (Оценка времени и сил)
Проблема: Очень сложно угадать, сколько времени займёт программирование. Автор приводит пример: огромный мост в США построили точно в срок, а операционную систему для IBM делали на 4 года дольше planned.

Как они оценивают:
Собирается несколько самых опытных программистов (экспертов). Они:

Дробят большую задачу на много маленьких.

Каждый наедине пишет, сколько времени, по его мнению, займёт каждая маленькая задача. Причём пишет три цифры:

Если всё будет идеально (оптимистичная оценка).

Скорее всего, так и будет (реалистичная оценка).

Если всё пойдёт наперекосяк (пессимистичная оценка).

Потом все оценки сводятся в одну среднюю.

Детальный план:
Когда все требования готовы, их режут на кусочки — "фичи" (фичи — это возможности программы, например, "меню" или "поддержка Bluetooth").

Фичи сортируют по важности.

Решают, в каком порядке их делать.

Каждую фичу делят на задачи поменьше, которые можно сделать за 4 часа — 4 дня.

На каждую задачу назначают ответственного.

=== Организация работы (Конфигурация проекта)
Это создание общих правил для всех, чтобы работать было удобно и ничего не терялось.

. Что они регулируют этими правилами:

. Из каких частей состоит программа.

. Как собирать (компилировать) программу из кода.

. Кто и какие файлы может изменять.

. Какую структуру папок использовать.

. Как выпускать новые версии программы.

. Как объединять код, написанный разными людьми.

== Требования

Самая большая и важная работа — это не писать код, а понять и записать, ЧТО должна делать программа. На это уходит чуть ли не половина всего времени!

Откуда берутся требования:

Желания заказчика ("хочу вот такую кнопку").

Эти желания превращаются в требования к системе (более техническое описание).

А те — в требования к программе (очень детальное описание для программистов).

Какими бывают требования:

Функциональные: Что программа должна делать (например, "показывать значение температуры на экране").

Нефункциональные: Как она должна это делать (например, "работать быстро", "занимать мало памяти", "быть надёжной").

Золотое правило: Требование должно быть сформулировано так, чтобы его можно было проверить тестом.

Плохо: "Интерфейс должен быть удобным." (Непонятно, как проверять).

Хорошо: "Пользователь должен найти нужную настройку не более чем за 3 клика." (Можно сесть и проверить).

== Архитектура
Прежде чем строить дом, нужен чертёж. Прежде чем писать код, нужна архитектура. Это схема, из каких частей будет состоять программа и как они будут друг с другом общаться.

Что входит в архитектуру:

Список основных деталей (модулей, библиотек).

Схема, как эти детали взаимодействуют.

Описание самых важных классов (кирпичиков программы) и функций.

Диаграммы, которые это всё показывают наглядно (часто рисуют в UML — это как универсальный язык для чертежей программ).

Секрет успеха — "Шаблоны проектирования":
Это готовые, проверенные решения для частых проблем. Вместо того чтобы каждый раз придумывать велосипед, умные программисты используют эти шаблоны. Например:

Singleton — чтобы какой-то объект был в программе в единственном экземпляре (например, главное окно).

Factory — "фабрика", которая создаёт другие объекты по запросу.

Observer — механизм, чтобы одна часть программы могла "подслушивать" события в другой (например, кнопка "сообщает" всем, что на неё нажали).

== Юнит-тесты

Как пишут код:

Для датчиков — на C++.

Для программ на компьютере — на C#.

Есть строгие правила оформления кода (как писать названия переменных, где ставить скобки), чтобы весь код выглядел одинаково и его было легко читать.

Проверка кода до запуска (Статический анализ):
Специальные программы-помощники (вроде Lint) читают код и ищут в нём глупые ошибки, опечатки и места, где нарушены правила. Это как проверка сочинения орфографическим корректором.

Юнит-тесты (Модульные тесты):
Это самые первые и маленькие тесты. Их пишут сами программисты.

Что это: Маленькая программка, которая проверяет работу одной маленькой функции (например, функция сложения двух чисел).

Зачем: Чтобы сразу быть уверенным, что твоя функция работает правильно, и чтобы потом, когда кто-то другой будет изменять код, он ненароком не сломал её.

Mock-объекты: Часто функция должна общаться с "железом" или базой данных. Чтобы测试ить её на компьютере программиста, создают "муляж" (mock) этого железа, который ведёт себя как настоящее, но на самом деле просто "притворяется".

Главный секрет — проверка код коллегами (Peer Review):
Никакие автоматические тесты не заменят взгляд опытного коллеги. Поэтому программисты обязательно показывают свой код друг другу перед тем, как сдать работу. Это помогает:

Найти ошибки, которые не видят машины.

Узнать друг у друга новые приёмы.

Следить, чтобы весь код в проекте был в одном стиле.

== Главный вывод

Презентация показывает, что создание программ для серьёзных приборов — это не искусство, а точная инженерная наука. Всё делается по строгому плану, с постоянными проверками и перепроверками. Главные цели — надежность, безопасность и качество, потому что цена ошибки может быть очень высока.