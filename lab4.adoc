= Лабораторная работа №4

:toc: macro
:toc-title: Оглавление

include::Titulnik.adoc[]

toc::[]

== Введение

=== Тема лекции

На этой лекции рассматриваются принципы создания переносимого программного обеспечения для встраиваемых систем. Мы изучим систему типов в C++, преобразования между ними, механизмы работы с указателями и ссылками, а также основы организации памяти и регистровой модели на примере микроконтроллера STM32F411.

== Основные термины и определения

Портируемость (Portability) — это качество программного кода, которое позволяет адаптировать его для работы на разных аппаратных платформах или с различными микроконтроллерами без значительных изменений.

Тип данных (Data Type) — это классификация данных, которая определяет диапазон возможных значений переменной и набор допустимых операций для работы с ней.

Указатель (Pointer) — это переменная, значением которой является адрес в памяти, где хранятся другие данные.

Ссылка (Reference) — это альтернативное имя (псевдоним) для уже существующей переменной.

Регистр (Register) — это специальная ячейка памяти, расположенная непосредственно в процессоре или периферийном устройстве, используемая для хранения управляющих сигналов или данных.

== Типы данных в C++

=== Базовые типы данных

В C++ существуют фундаментальные типы данных, среди которых:

bool — логический тип для хранения значений true/false (1 байт).

char — символьный тип (1 байт).

int — целочисленный тип (обычно 4 байта).

float — число с плавающей запятой одинарной точности (4 байта).

double — число с плавающей запятой двойной точности (8 байт).

=== Модификаторы типов

Поведение и размер базовых типов можно изменять с помощью модификаторов:

short — уменьшает размер типа (например, 2 байта для short int).

long — увеличивает размер типа (например, 8 байт для long long).

unsigned — указывает, что тип может хранить только неотрицательные значения.

=== Гарантированные размеры типов

Поскольку размеры типов могут зависеть от компилятора и архитектуры, для обеспечения переносимости рекомендуется применять типы с фиксированным размером из заголовка <cstdint>:

std::uint8_t — беззнаковое 8-битное целое.

std::int32_t — знаковое 32-битное целое.

=== Пользовательские типы данных

Программист может создавать собственные составные типы, используя ключевые слова struct и class. Например, можно определить структуру Complex для представления комплексных чисел.

== Преобразования типов

=== Неявное преобразование

Компилятор способен автоматически выполнять преобразование типов в выражениях, что иногда может приводить к неочевидным результатам:

cpp
int a = 3.14; // Произойдёт усечение, a = 3
bool b = -4;  // Любое ненулевое значение преобразуется в true

=== Явное преобразование

Для точного контроля над преобразованиями следует использовать операторы приведения:

static_cast — для стандартных и безопасных преобразований.

reinterpret_cast — для низкоуровневых преобразований между несвязанными типами.

const_cast — для изменения константности переменной.

dynamic_cast — для безопасного приведения типов в иерархиях наследования.

Пример использования:

cpp
int a = static_cast<int>(3.14); // Явное преобразование в int
auto ptr = reinterpret_cast<volatile uint32_t*>(0x40010000); // Интерпретация числа как адреса

== Указатели и ссылки

=== Работа с указателями

Указатель — это переменная, содержащая адрес другой переменной.

cpp
int c = 463;
int* ptr = &c; // В переменной ptr хранится адрес переменной c
Основные операции:

Получение адреса: &

Обращение к значению по адресу (разыменование): *

Арифметические операции: +, -, ++, --

Пример обхода массива:

cpp
int arr[] = {1, 2, 3, 4, 5};
int* ptr = arr; // Указатель на начало массива
ptr++; // Смещение указателя на следующий элемент (arr[1])

=== Указатели и константность

const int* ptr — указатель на константные данные (значение нельзя изменить).

int* const ptr — константный указатель (адрес в указателе нельзя изменить).

=== Ссылки

Ссылка предоставляет альтернативное имя для существующей переменной.

cpp
int a = 0;
int& ref = a; // ref — это псевдоним для a
ref = 10;     // Значение a становится равным 10
Отличия от указателей:

Ссылка обязана быть проинициализирована при создании.

После инициализации ссылку нельзя перенаправить на другую переменную.

Над ссылками не предусмотрены арифметические операции.

== Регистры

=== Регистры общего назначения (РОН)

Микроконтроллер Cortex-M4 обладает набором из 16 регистров общего назначения (R0-R15):

R0-R3, R12 — используются для временных данных.

R4-R11 — регистры, значения которых должны сохраняться между вызовами функций.

R13 (SP) — указатель стека (Stack Pointer).

R14 (LR) — регистр связи (Link Register), хранит адрес возврата.

R15 (PC) — счётчик команд (Program Counter).

=== Специальные регистры
Эти регистры используются для конфигурации и управления периферийными устройствами. Каждый такой регистр характеризуется:

Физическим адресом в памяти.

Разрядностью (чаще всего 32 бита).

Набором полей (битовых полей), каждое из которых отвечает за конкретную функцию устройства.

== Операции с указателями

=== Арифметика указателей
С указателями допустимы операции сложения, вычитания и сравнения.

cpp
int arr[] = {1, 2, 3, 4, 5};
int* ptr = arr;
ptr += 2; // Указатель сместится и будет указывать на arr[2]
Важно: при арифметических операциях указатель смещается не на байты, а на размер типа данных, на который он указывает (sizeof(*ptr)).

=== Сравнение указателей
Указатели можно проверять на равенство nullptr и сравнивать друг с другом.

cpp
if (ptr != nullptr) {
    // Работа с данными через указатель
}
== Заключение

В рамках лекции были разобраны фундаментальные принципы написания переносимого кода для встраиваемых систем:

Применение типов с фиксированным размером для независимости от платформы.

Использование явных преобразований типов для исключения неоднозначностей.

Эффективное управление памятью с помощью указателей и ссылок.

Организация доступа к регистрам микроконтроллера через средства C++.

Глубокое понимание этих концепций является основой для создания надежного и легко переносимого программного обеспечения для микроконтроллеров.


== Код программы для переключения состояния светодиода:

include::Code.adoc[]